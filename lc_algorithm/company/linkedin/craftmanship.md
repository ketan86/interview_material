# Three main pillar of Engineering

1. leadership
2. craftsmanship
3. execution

Have a look at the Venn diagram above (or that's attached to this e-mail).
There's a circle labeled leadership, one labeled craftsmanship, and another
labeled execution. Engineering teams that produce the most long-term innovation
and value are ones where these three characteristics of their output are
balanced and in alignment.

Granted, it is possible to do good short-term work when one of these
characteristics is lagging or missing. For example, you can execute well and get
good short-term results while throwing craftsmanship out of the window, although
that typically leads to very serious team and technology stability issues longer
term. You can sometimes have good short-term execution and craftsmanship in the
absence of solid leadership just because the team is outstanding, although
situations like this are almost never sustainable over the longer term. And if
you have great leadership and craftsmanship, you might end up having a
transformative personal experience building something really cool, but without
execution, you are probably toast as soon as your stockpile of money runs out.

The holy grail is to have leadership, craftsmanship, and execution in balance,
valued, and actively practiced throughout a technology organization at all
levels.

## Leadership

Leadership as we typically define it is inspiring others to accomplish a common
objective or mission. As an engineer you often inspire by setting a great
example for your peers through the code you write or the technical decisions
that you drive, by leverage that your work creates for others, by coaching and
mentoring those with different experiences than yours, or by the impact that
your work has on our members. As a manager your leadership responsibilities
expand beyond owning a technical roadmap and deliverables to co-owing career
development of the folks whom you manage, ensuring that everyone understands
their career path, is recognized for the work they do, and has the appropriate
resources available to them to do their job and to advance toward their
long-term career objectives.

## Craftsmanship

Craftsmanship is sometimes defined as the quality of design and workmanship
shown in something made by hand. It is in some ways the most important aspect of
our job as engineers, and yet one of the most difficult to precisely quantify.
Fortunately, it is easy to spot and describe anti-patterns for engineering
craftsmanship: unreadable, unmaintainable, untestable, poorly documented,
non-reusable code; purposeless complexity and ugly systems architecture; crappy
user experiences (which applies to APIs and infrastructure as easily as it does
to consumer-facing apps); and brittle, flaky, unpredictable services that are
difficult to troubleshoot and that take a long time to recover from an error
state. There are some good resources out there on engineering craftsmanship,
although perhaps the best at your disposal is your peers. There is an amazing
group of folks here at LinkedIn with a wealth of backgrounds and experiences
from which each of us can benefit to become better at our craft.

## Execution

Execution is probably the thing that requires the least explanation. Simply put,
it is getting shit done. That said, good execution is no easy thing. It requires
solid collaboration, quantifying and measuring success, setting aggressive
goals, and holding yourself and others accountable for meeting commitments.
Moreover, good long-term execution requires a shared understanding of clearly
articulated strategy (whether it is for a small project or a company-wide
moon-shot), and a focus on balancing delivery of results for the short-term with
creating highly-leveraged value for the long-term. Not at all easy, although
something this team is better at than any other with which I've worked.

Valuing a balance of leadership, craftsmanship, and execution, and trying to pay
attention to all three in the presence of your regularly scheduled daily circus
is tough. I struggle constantly with getting the balance right. The struggle is
worth having though, in fact a necessity, because it is literally the only way
for us to fully deliver on LinkedIn's mission for our members, and the only way
for us to be the type of engineering team that I want us to be. Our mission is
too important, and our potential is too great to do anything less.

## SDLC

- Requirement Gathering

  - Identifying the Users
  - User Cases
  - How product is used?

- Plan

  - Decide StakeHolders
  - Time Estimation
  - Resource Estimation
  - Cost Estimation
  - Story Estimations
  - Dependencies identification

- Design

  - Functional Requirement
  - Non-Functional Requirement
  - High Level Design
  - Component Identification
  - Tech Stack Evaluation/Decision
  - Monitoring
  - Alerting
  - Analytics
  - Debugability
  - Scalability
  - Security

- Develop

  - Component Level Design
  - Design Review
  - Implementation
  - UnitTesting
  - Code Review

- Test

  - Functional Testing
  - End to End Testing
  - Integration Testing
  - Code Coverage
  - Bug Identification/Reporting/Fixing

- Deploy

  - Release
  - Dependencies Management
  - Post-Deployment Checks
  - Rollback Procedures

- Maintain
  - Bug Fixes
  - Upgrade
  - Security Patches

## What is craftsmanship ?

- It is an ability to create something elegant and high quality that delivers value while being able to perform and scale up gracefully.

- Artifacts build by individual become the building blocks for something larger that others are building so how well someone build their artifacts greatly impacts
  other engineers and their work.

- I have read somewhere you can not rely on social relationship (who each person is and how each person relates to others) after the team grows beyond
  150 people to get acceptable level of quality work.

- Engineering is all about recognizing the constraints and negotiating the right tradeoffs between them.

Strong craftsmanship bring these advantages:

- Higher Productivity per Developer
  Time spent creating high quality code
  means developers don’t have to spend time fixing future issues. In other
  words, you move slower now to move faster in the future. Moving faster in the
  future means average output is higher over the long term.

- Attract and Retain Talent
  Experienced developers have usually seen low
  quality code bases and the debilitating effects it has on productivity. No
  one wants to join a team where craftsmanship is subpar. Likewise, no one
  wants to work on low quality code and systems. Craftsmanship is key to
  continued developer happiness and makes it easier to persuade candidates to
  join your team in the first place.

- Smaller Teams, More Agility, and More Innovation
  Related the first point, when you create an environment with higher
  productivity per developer, you build a solid foundation that allows
  your team to get more stuff done with less people. Smaller teams enable
  companies to change direction faster and
  innovate faster.

- There are five key areas of focus for software engineering craftsmanship.
  If you can focus on craftsmanship around each of these areas, then your
  engineering team will create strong competitive advantages for your company.

Key Areas of Software Craftsmanship:

There are five key areas of focus for software engineering craftsmanship. If
you can focus on craftsmanship around each of these areas, then your engineering
team will create strong competitive advantages for your company.

1. Security & Privacy

Obviously, one of the most critical aspects of any software product is
ensuring the security and privacy of customer, partner, and company data.
Not every company is collecting credit cards or managing personal health
records but trust is an important part of maintaining customer and partner
relationships and if that trust is at risk, so is your entire business.
Your software artisans should understand basic security issues like XSS,
code injection, encryption, and follow security best practices. Ideally,
your team would have access to security specialists who can provide support
beyond the basics including reviewing designs, reviewing code, and running
penetration tests on systems. The key here is making sure Security &
Privacy are considerations when you are designing and building any system.

2. Systems Architecture & Design

Some software engineers have a tendency to jump right into coding and skip
over an area that pays huge dividends: system architecture & design. A big
part of why system architecture & design is valuable is because it forces
engineers to really sit down and think. What are the business goals of this
features? What are our assumptions? What should we do about security &
privacy? How much will it cost? What are alternative ways to solve the
problem or build the feature? All of these questions and more should be
thought about and more importantly documented. Documenting is a way for
software artisans to clearly communicate their understanding of the problem
and their proposed solution and garner feedback from other engineers,
security specialists, product folks, and other stakeholders. Investing time
and energy in this step ensure that folks are aligned before making further,
more-costly investments in coding and beyond which are orders of magnitude
more expensive to change and fix.

3. Code Quality & Reviews

High code quality is perhaps the easiest area of software artisanship to
achieve yet is often neglected. Code quality includes things like style,
documentation, and most importantly unit and functional tests. Of course, no
team is perfect and not all code should or will have tests. The important
thing is that code quality should be monotonically increasing towards
perfection. A more harsh view might be: If code doesn’t come with tests it
means you are either arrogant or lazy or both. Neither characteristics are
consistent with software artisans.

Another important part of code quality is the act of reviewing code. There are
many tools such as Crucible, RB, Gerrit, etc that facilitate code reviews. Even
something as lightweight as pull-requests are better than not doing code
reviews. Regardless of how your team accomplishes it, code reviews are
incredibly valuable. They allow software artisans to provide feedback, ensure
quality, learn new approaches to solving problems, discover new libraries, and
see how code is changing over time. Code reviews are probably the single most
powerful way of helping software artisans improve over time and bring a team up
to a consistent level of artisanship.

4. Operational Excellence

Whether a website or app, most software products have some aspect of delivery
over a network and without operation greatness, a customer might have a
suboptimal experience which negatively affects the company’s bottom line.
Operational excellence in software craftsmanship is about deployment,
monitoring, uptime, and performance. Amazingly, we live in a time where hardware
has been “eaten” by software and clouds like AWS, Google Cloud, and Azure enable
tooling to support ease of deployment, monitoring, and robust systems located in
many data centers and geo-locations which can scale based on traffic.
Operational excellence can be taken to such an extreme with the modern cloud
computing infrastructure where one doesn’t actually need to “operate” anything.
For example AWS and Google will operate (e.g. manage) databases, storage, and
even compute with services like AWS Lambda and Google Cloud Functions. Of course
monitoring, automating, and optimizing customer experience is still up to
software engineers but it just means more focus and energy can be spent on
efforts that differentiate the product and bring value to the business.

5. Curiosity, Creativity, & Experimentation

The final area that is an imperative for developing software artisans is
curiosity, creativity, and experimentation. Nurturing the drive to be creative
and providing a safe space for experimentation is key to true innovation. The
previous four areas are table stakes for artisanal software but without
innovation you product and company will eventually be replaced by a better
mousetrap.

### Example

- Frameworks
- Wood Working

### Methodology

1. You needed to solve the client's problem. If you hadn't done that, you'd failed.
2. You needed to make sure that your code was well-understood and well-documented. You needed proper comments and documented module design and testing documentation. You could have the most wonderful code that solved the client's problem, but if no one could maintain it when you were gone, then you'd failed again.
3. Lastly, your code needed to be elegant. In other words, code needed to jump around as little as possible and use space as efficiently as possible.

### Manifesto

1. Not only working software but also well-crafted software
2. Not only responding to change but also steadily adding value
3. Not only individuals and interactions but also a community of professional
4. Not only customer collaboration but also productive partnership

### Artist

I have always seen programming as an "Art"; the Art of representing patterns(events). So i see myself as a "Code Artist".

### Pillars

1. Quality
2. Security and Privacy
3. Performance and Scalability
4. Deliver Value
5. Elegant

## Why ?

It helps build better products and engineers. It helps in reducing the friction between teams and making a real progress towards the larger goal.

## Example:

- Product Release Cycle (3x3 LinkedIn Release Process for Mobile)[https://engineering.linkedin.com/blog/2016/02/3x3--speeding-up-mobile-releases]
  - Fix release cycles - Monthly
  - Prior to each release, we picked a release candidate and hand over to testing team that takes a close to a week to bless that candidate before
    we can release that candidate.
  - If bugs are found, a new build is handed over and testing repeats.
  - Product Manager and Marketing people had to plan their schedules around the release process with the hope that each release goes out on time.

## Code-Review Process

- Process of managing the quality of the product
  - allows engineer to get feedback on their work
  - exchange knowledge
  - let other engineer learn about the project
  - allows reviewers to ask questions without knowing the change.

https://engineering.linkedin.com/blog/2018/06/scaling-collective-code-ownership-with-code-reviews

- Ownership (impacts quality)
  - Code that does not have a strong ownership (individual, team) suffers quality.
- Code Review (way more than just quality assurance)
  - Small and Frequent
  - Evolvability and Maintainability rather than just bugs
- Review Process (Mechanism for scaling code ownership)
  - A robust review process can make team efficient in both reviews and development.

ex. It's like a wheel of the car. It wheels were not reviews for it's shape,
the car will always have unstable ride.

### Tips for Maintainer:

- Take your time - Effective 300 line of code (LOC) / hour
- Hurry Up - Receiving feedback in timely manner
- Don't do it all once - Max time spent 60 but no over 90 minutes
- Communicate - Clear communication reduces back and forth
- Focus on useful feedback - Don't get attached to small things and focus on overall impact.

### Tips for Contributor:

- Take your time - Take time in ensuring the code is review ready
- Make small changes - Ideal 200 LOC and 400 LOC maximum.
- Respond to feedback promptly - Reviewer may need

### Reviewer Tips:

- Title, Description, Reviewers, Attachments, Jira Details, Tests, Coverage, Security Violation, Linting
- Code Comments - Add meaningful comments
- Run code locally to for critical PRs.

## Project Planning

## Analytics

## Monitoring

https://www.agilepartner.net/en/le-software-craftsman-super-developpeur/

Quality
Review of the code
The significance of a test suite.
Is there a cost to code review?
Any trade off for code review?
How did you teach your junior engineer about craftsmanship, give example?
Ability to make decisions and lead by example.
Choose between scalability, performance, and quality.

### Cyclomatic complexity:

Cyclomatic complexity of a code section is the quantitative measure of the
number of linearly independent paths in it. It is a software metric used to
indicate the complexity of a program. It is computed using the Control Flow
Graph of the program. The nodes in the graph indicate the smallest group of
commands of a program, and a directed edge in it connects the two nodes i.e. if
second command might immediately follow the first command.

For example, if source code contains no control flow statement then its
cyclomatic complexity will be 1 and source code contains a single path in it.
Similarly, if the source code contains one if condition then cyclomatic
complexity will be 2 because there will be two paths one for true and the other
for false.

Mathematically, for a structured program, the directed graph inside control flow
is the edge joining two basic blocks of the program as control may pass from
first to second. So, cyclomatic complexity M would be defined as,

M = E – N + 2P

where,
E = the number of edges in the control flow graph
N = the number of nodes in the control flow graph
P = the number of connected components

Steps that should be followed in calculating cyclomatic complexity and test cases design are:

Construction of graph with nodes and edges from code.
Identification of independent paths.
Cyclomatic Complexity Calculation
Design of Test Cases

#### Use of Cyclomatic Complexity:

Determining the independent path executions thus proven to be very helpful for Developers and Testers.
It can make sure that every path have been tested at least once.
Thus help to focus more on uncovered paths.
Code coverage can be improved.
Risk associated with program can be evaluated.
These metrics being used earlier in the program helps in reducing the risks.

#### Advantages of Cyclomatic Complexity:.

It can be used as a quality metric, gives relative complexity of various designs.
It is able to compute faster than the Halstead’s metrics.
It is used to measure the minimum effort and best areas of concentration for testing.
It is able to guide the testing process.
It is easy to apply.

#### Disadvantages of Cyclomatic Complexity:

It is the measure of the programs’ control complexity and not the data the data complexity.
In this, nested conditional structures are harder to understand than non-nested structures.
In case of simple comparisons and decision structures, it may give a misleading figure.

- Customers of LinkedIn (Professional)
  - Job Seeker
  - Learner
  - Recruiters
  - Company
- Products
  - Marketing
  - Recruiting
  - Sales Navigator
  - Learning
  - Awareness
  - Branding
    - Free-Lancer
- Beyond meeting basic needs
  - LinkedIn Recruiting -> Recommend
- Customer Delight
  - not only use but recommend candidates

Internal and External Quality:

What Quality means ?

1. functional
2. monitor
3. maintainable
4. scalable
5. testability
6. documentation

7. functional
8. reliable
9. available
10. scalable

What is good software design?

1. Modular
2. Naming Convention
3. Consistent Architectural Patterns

- following well-known patters in existing code before re-inventing new ones.
- principle/guidelines but not rules

4. Privacy/Security
5. Test (Unit/Integration) Friendly
6. Extensible

- Inheritance
- Polyphormism

6. Code Formatting / Readability
7. Reusability

Craftsmanship Example:

- SSL Certificate Rotation
